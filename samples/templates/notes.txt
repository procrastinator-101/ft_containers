templates:

-   template class : instantiation of a class template
-   template function : instantiation of a function template

concepts:
-	generic function = function template
-	generated function = template function = instantiated function = function instance


-	function template instantiation :
	-	implicit : through a function  call
	-	explicit : through creating functions (with specific types) from function templates (with template types).
	Ex :	-	template<class T> f(T arg){}
			-	template<> f<int>(int arg){} --> explicit instantiation
			-	f(12.3)	--> implicit instantiation


calling a template function :
	-   foo<types>(args)
		does not look for explicit specific functions written in the old style.
	-   foo<>(args)
		deduces the right specific function to call. It does not look for explicit 
		specific functions written in the old style.
	-   foo(args)
		deduces the right specific function to call (explicit specific functions are included).


-	Template definitions are not subject to the one-definition rule, and functions instantiated from function 
	templates are implicitly inline, so they are exempt from the one-definition rule.


abbreviated function template :
	-	When the auto keyword is used as a parameter type in a normal function, the compiler will
		automatically convert the function into a function template with each auto parameter becoming
		an independent template type parameter
	-	Ex : auto foo(auto a, auto b);


Non-type parameters:
	-	Ex: template<typename T, int var) --> var is a non-type parameter (can't have default value untill c++11)
	-	A non-type template-parameter shall have one of the following (optionally cv-qualified) types:
		—	integral or enumeration type,
		—	pointer to a global object or function,
		—	reference to a global object or function,
		—	pointer to member (argument must be expressed as &Class::Member)
		-	std::nullptr_t
		-	A floating point type(since C++20)
	-	Thus, non-type parameters should themselves be thought of as constants, since their values cannot be changed.

-	default template arguments for a function template are a C++11 extension;

template member definition:
	-	Each templated member function defined outside the class declaration needs its own template declaration.
	-	when defining a member function of a class template outside of the class, the use of type<> for scope is mandatory.
	Ex :
		-	template <typename T> void array<t>::getSize(){}; //valid
		-	template <typename T> void array::getSize(){}; //invalid --> refers to a non-template class array


-	a specialized member function must specialize an explicit function (not one that the compiler is providing a
	default for, Ex: ctors)
///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

using NewTypeName = typeName;    ---> tyepedef typeName NewTypeName;




Member template :
	-   member function template.
	-   nested class template.


-   Local classes are not allowed to have member templates.


-   Member template functions cannot be virtual functions and cannot override virtual 
	functions from a base class when they are declared with the same name as a base class 
	virtual function.

typeof : a Gcc extension that work like typeid but just at compile-time.


-   