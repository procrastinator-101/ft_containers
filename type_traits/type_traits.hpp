#ifndef TYPE_TRAITS_HPP
# define TYPE_TRAITS_HPP

#include "../iterator/iterator_traits.hpp"
#include <iterator>
#include <type_traits>

namespace ft
{
	/////////////////////////////////////////////////////////////////////////////////////////////////////
	/// Integral_constant
	/////////////////////////////////////////////////////////////////////////////////////////////////////
	template <class T, T v>
	struct integral_constant
	{
		static const T	value = v;
		typedef T value_type;
		typedef integral_constant<T,v> type;

		operator const value_type() const
		{
			return v;
		}
	};

	typedef integral_constant<bool, true> true_type;
	typedef integral_constant<bool, false> false_type;
	/////////////////////////////////////////////////////////////////////////////////////////////////////
	/// Integral_constant End
	/////////////////////////////////////////////////////////////////////////////////////////////////////

	/////////////////////////////////////////////////////////////////////////////////////////////////////
	/// remove_cv
	/////////////////////////////////////////////////////////////////////////////////////////////////////
	template <class T>
	struct remove_cv
	{
		typedef T type;
	};

	template <class T>
	struct remove_cv<const T>
	{
		typedef T type;
	};

	template <class T>
	struct remove_cv<volatile T>
	{
		typedef T type;
	};

	template <class T>
	struct remove_cv<const volatile T>
	{
		typedef T type;
	};
	/////////////////////////////////////////////////////////////////////////////////////////////////////
	/// remove_cv End
	/////////////////////////////////////////////////////////////////////////////////////////////////////


	/////////////////////////////////////////////////////////////////////////////////////////////////////
	/// is_integral
	/////////////////////////////////////////////////////////////////////////////////////////////////////
	template <class T>
	struct is_integral_base : false_type {};

	template <class T>
	struct is_integral : is_integral_base<typename remove_cv<T>::type> {};

	template<>
	struct is_integral_base<bool> : true_type {};
	template<>
	struct is_integral_base<char> : true_type {};
	//////////////////////////////////////////////////
	/// c++ 11 types
	//////////////////////////////////////////////////
	// template<>
	// struct is_integral_base<char16_t> : true_type {};
	// template<>
	// struct is_integral_base<char32_t> : true_type {};
	//////////////////////////////////////////////////
	template<>
	struct is_integral_base<wchar_t> : true_type {};
	template<>
	struct is_integral_base<signed char> : true_type {};
	template<>
	struct is_integral_base<short int> : true_type {};
	template<>
	struct is_integral_base<int> : true_type {};
	template<>
	struct is_integral_base<long int> : true_type {};
	template<>
	struct is_integral_base<long long int> : true_type {};
	template<>
	struct is_integral_base<unsigned char> : true_type {};
	template<>
	struct is_integral_base<unsigned short int> : true_type {};
	template<>
	struct is_integral_base<unsigned int> : true_type {};
	template<>
	struct is_integral_base<unsigned long int> : true_type {};
	template<>
	struct is_integral_base<unsigned long long int> : true_type {};
	/////////////////////////////////////////////////////////////////////////////////////////////////////
	/// is_integral End
	/////////////////////////////////////////////////////////////////////////////////////////////////////

	/////////////////////////////////////////////////////////////////////////////////////////////////////
	/// is_same
	/////////////////////////////////////////////////////////////////////////////////////////////////////
	template<typename T, typename U>
	struct is_same : false_type {};

	template<typename T>
	struct is_same<T, T> : true_type {};
	/////////////////////////////////////////////////////////////////////////////////////////////////////
	/// is_same End
	/////////////////////////////////////////////////////////////////////////////////////////////////////

	/////////////////////////////////////////////////////////////////////////////////////////////////////
	/// enable_if
	/////////////////////////////////////////////////////////////////////////////////////////////////////
	template <bool Cond, class T = void>
	struct enable_if
	{
	};

	template <class T>
	struct enable_if <true, T>
	{
		typedef T type;
	};
	/////////////////////////////////////////////////////////////////////////////////////////////////////
	/// enable_if End
	/////////////////////////////////////////////////////////////////////////////////////////////////////


	/////////////////////////////////////////////////////////////////////////////////////////////////////
	/// void_t
	/////////////////////////////////////////////////////////////////////////////////////////////////////
	template<typename T>
	struct void_t
	{
		typedef void type;
	};
	/////////////////////////////////////////////////////////////////////////////////////////////////////
	/// void_t End
	/////////////////////////////////////////////////////////////////////////////////////////////////////


	/////////////////////////////////////////////////////////////////////////////////////////////////////
	/// is_iterator
	/////////////////////////////////////////////////////////////////////////////////////////////////////
	template<typename T, typename U = void, typename V = void, typename W = void, typename X = void, typename Y = void>
	struct is_iterator : false_type {};

	template<typename T>
	struct is_iterator <	T, 
						typename void_t<typename T::difference_type>::type,
						typename void_t<typename T::value_type>::type,
						typename void_t<typename T::pointer>::type,
						typename void_t<typename T::reference>::type,
						typename void_t<typename T::iterator_category>::type>
						: true_type {};
	/////////////////////////////////////////////////////////////////////////////////////////////////////
	/// is_iterator End
	/////////////////////////////////////////////////////////////////////////////////////////////////////


	/////////////////////////////////////////////////////////////////////////////////////////////////////
	/// is_forward_iterator
	/////////////////////////////////////////////////////////////////////////////////////////////////////
	template<typename Iterator, typename T = void>
	struct is_forward_iterator : false_type {};

	template<typename Iterator>
	struct is_forward_iterator<Iterator, typename enable_if<
										is_same<typename iterator_traits<Iterator>::iterator_category, std::forward_iterator_tag>::value, 
										void>::type>
										: true_type {};

	template<typename Iterator>
	struct is_forward_iterator<Iterator, typename enable_if<
										is_same<typename iterator_traits<Iterator>::iterator_category, std::bidirectional_iterator_tag>::value, 
										void>::type>
										: true_type {};

	template<typename Iterator>
	struct is_forward_iterator<Iterator, typename enable_if<
										is_same<typename iterator_traits<Iterator>::iterator_category, std::random_access_iterator_tag>::value, 
										void>::type>
										: true_type {};
	/////////////////////////////////////////////////////////////////////////////////////////////////////
	/// is_forward_iterator End
	/////////////////////////////////////////////////////////////////////////////////////////////////////


	/////////////////////////////////////////////////////////////////////////////////////////////////////
	/// is_random_access_iterator
	/////////////////////////////////////////////////////////////////////////////////////////////////////
	template<typename Iterator, typename T = void>
	struct is_random_access_iterator : false_type {};

	template<typename Iterator>
	struct is_random_access_iterator<Iterator, typename enable_if<
											is_same<typename iterator_traits<Iterator>::iterator_category, std::random_access_iterator_tag>::value, 
											void>::type>
											: true_type {};
	/////////////////////////////////////////////////////////////////////////////////////////////////////
	/// is_random_access_iterator End
	/////////////////////////////////////////////////////////////////////////////////////////////////////
}

#endif